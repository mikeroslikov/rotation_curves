<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotation Curve Visualizer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const RotationCurveVisualizer = () => {
          const [selectedCurve, setSelectedCurve] = useState('ngc3198');
          const orbitCanvasRef = useRef(null);
          const chartCanvasRef = useRef(null);
          const animationRef = useRef(null);
          const particlesRef = useRef([]);

          // Real data from NGC3198
          const ngc3198Data = [
            [0.5, 55], [1.0, 95], [1.5, 115], [2.0, 130], [2.5, 140],
            [3.0, 147], [3.5, 152], [4.0, 155], [4.5, 158], [5.0, 160],
            [5.5, 161], [6.0, 162], [6.5, 162], [7.0, 162], [7.5, 162],
            [8.0, 161], [8.5, 161], [9.0, 161], [9.5, 160], [10.0, 160],
            [11.0, 159], [12.0, 158], [13.0, 157], [14.0, 157], [15.0, 156],
            [16.0, 156], [17.0, 155], [18.0, 155], [19.0, 154], [20.0, 154],
            [22.0, 153], [24.0, 152], [26.0, 151], [28.0, 150], [30.0, 150]
          ];

          const interpolateNGC3198 = (r) => {
            const rKpc = 0.5 + (r - 0.1) * (30 - 0.5) / (2 - 0.1);
            
            for (let i = 0; i < ngc3198Data.length - 1; i++) {
              if (rKpc >= ngc3198Data[i][0] && rKpc <= ngc3198Data[i + 1][0]) {
                const r1 = ngc3198Data[i][0];
                const v1 = ngc3198Data[i][1];
                const r2 = ngc3198Data[i + 1][0];
                const v2 = ngc3198Data[i + 1][1];
                const t = (rKpc - r1) / (r2 - r1);
                return v1 + t * (v2 - v1);
              }
            }
            if (rKpc < ngc3198Data[0][0]) return ngc3198Data[0][1];
            return ngc3198Data[ngc3198Data.length - 1][1];
          };

          const calculateEnclosedMass = (velocityFunc) => {
            return (r) => {
              const v = velocityFunc(r);
              return (v * v * r) / 100;
            };
          };

          const rotationCurves = {
            ngc3198: {
              name: 'NGC 3198 (Real Galaxy)',
              velocityFunc: interpolateNGC3198,
              description: 'Actual observed rotation curve from NGC3198',
              enclosedMassFunc: calculateEnclosedMass(interpolateNGC3198)
            },
            homogeneousDisk: {
              name: 'Homogeneous Disk',
              velocityFunc: (r) => {
                const diskRadius = 1.0;
                if (r < diskRadius) {
                  return r * 150;
                } else {
                  return 150 / Math.sqrt(r / diskRadius);
                }
              },
              description: 'Uniform surface density until r=1, then Keplerian',
              enclosedMassFunc: calculateEnclosedMass((r) => {
                const diskRadius = 1.0;
                if (r < diskRadius) {
                  return r * 150;
                } else {
                  return 150 / Math.sqrt(r / diskRadius);
                }
              })
            },
            wheel: {
              name: 'Rigid Body (Wheel)',
              velocityFunc: (r) => r * 50,
              description: 'Linear increase with radius',
              enclosedMassFunc: calculateEnclosedMass((r) => r * 50)
            },
            solarSystem: {
              name: 'Solar System (Keplerian)',
              velocityFunc: (r) => 200 / Math.sqrt(r),
              description: 'Inverse square root decline',
              enclosedMassFunc: calculateEnclosedMass((r) => 200 / Math.sqrt(r))
            },
            flat: {
              name: 'Flat (Idealized)',
              velocityFunc: (r) => 150,
              description: 'Constant velocity (dark matter)',
              enclosedMassFunc: calculateEnclosedMass((r) => 150)
            }
          };

          const resetParticles = () => {
            const numParticles = 8;
            const particles = [];
            for (let i = 0; i < numParticles; i++) {
              const radius = 0.3 + (i * 0.2);
              particles.push({
                radius: radius,
                angle: 0,
                trail: []
              });
            }
            particlesRef.current = [...particles];
          };

          useEffect(() => {
            resetParticles();
          }, []);

          const handleCanvasClick = (e) => {
            const canvas = orbitCanvasRef.current;
            const rect = canvas.getBoundingClientRect();
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 120;
            
            const clickX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const clickY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const dx = clickX - centerX;
            const dy = clickY - centerY;
            const radius = Math.sqrt(dx * dx + dy * dy) / scale;
            
            if (radius > 0.15 && radius < 1.8) {
              const angle = Math.atan2(dy, dx);
              particlesRef.current.push({
                radius: radius,
                angle: angle,
                trail: []
              });
            }
          };

          // Draw the rotation curve chart
          useEffect(() => {
            const canvas = chartCanvasRef.current;
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 60;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;

            const curve = rotationCurves[selectedCurve];

            // Generate data points
            const dataPoints = [];
            for (let r = 0.1; r <= 2; r += 0.05) {
              dataPoints.push({
                r: r,
                v: curve.velocityFunc(r),
                m: curve.enclosedMassFunc(r)
              });
            }

            // Find max values
            const maxV = Math.max(...dataPoints.map(d => d.v));
            const maxM = Math.max(...dataPoints.map(d => d.m));

            // Clear canvas
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
              const y = padding + (chartHeight / 5) * i;
              ctx.beginPath();
              ctx.moveTo(padding, y);
              ctx.lineTo(width - padding, y);
              ctx.stroke();
            }

            // Draw axes
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Draw velocity curve
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            dataPoints.forEach((point, i) => {
              const x = padding + (point.r - 0.1) / 1.9 * chartWidth;
              const y = height - padding - (point.v / maxV) * chartHeight;
              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            });
            ctx.stroke();

            // Draw mass curve
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            dataPoints.forEach((point, i) => {
              const x = padding + (point.r - 0.1) / 1.9 * chartWidth;
              const y = height - padding - (point.m / maxM) * chartHeight;
              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            });
            ctx.stroke();

            // Draw labels
            ctx.fillStyle = '#9ca3af';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Radius (arbitrary units)', width / 2, height - 20);
            
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Velocity (km/s)', 0, 0);
            ctx.restore();

            ctx.save();
            ctx.translate(width - 20, height / 2);
            ctx.rotate(Math.PI / 2);
            ctx.fillText('Mass (arb)', 0, 0);
            ctx.restore();

            // Legend
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(padding, 20, 20, 10);
            ctx.fillStyle = '#e2e8f0';
            ctx.textAlign = 'left';
            ctx.fillText('Velocity', padding + 25, 28);

            ctx.fillStyle = '#f59e0b';
            ctx.fillRect(padding + 100, 20, 20, 10);
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('Mass', padding + 125, 28);

          }, [selectedCurve]);

          // Orbital animation
          useEffect(() => {
            const canvas = orbitCanvasRef.current;
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 120;

            const curve = rotationCurves[selectedCurve];

            const animate = () => {
              ctx.fillStyle = '#0a0a1a';
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              ctx.fillStyle = '#ffd700';
              ctx.beginPath();
              ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
              ctx.fill();

              ctx.strokeStyle = '#ffffff20';
              ctx.lineWidth = 1;
              particlesRef.current.forEach(particle => {
                ctx.beginPath();
                ctx.arc(centerX, centerY, particle.radius * scale, 0, Math.PI * 2);
                ctx.stroke();
              });

              particlesRef.current.forEach((particle, idx) => {
                const velocity = curve.velocityFunc(particle.radius);
                const angularVelocity = velocity / (particle.radius * scale) * 0.02;
                
                particle.angle += angularVelocity;

                const x = centerX + particle.radius * scale * Math.cos(particle.angle);
                const y = centerY + particle.radius * scale * Math.sin(particle.angle);

                const maxTrailLength = Math.floor(velocity / 3);
                
                particle.trail.push({ x, y });
                if (particle.trail.length > maxTrailLength) {
                  particle.trail.shift();
                }

                ctx.strokeStyle = `hsl(${(idx * 45) % 360}, 70%, 50%)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                particle.trail.forEach((point, i) => {
                  if (i === 0) {
                    ctx.moveTo(point.x, point.y);
                  } else {
                    ctx.lineTo(point.x, point.y);
                  }
                });
                ctx.stroke();

                ctx.fillStyle = `hsl(${(idx * 45) % 360}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
              });

              animationRef.current = requestAnimationFrame(animate);
            };

            animate();

            return () => {
              if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
              }
            };
          }, [selectedCurve]);

          const currentCurve = rotationCurves[selectedCurve];

          return (
            <div className="w-full min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 p-6">
              <div className="max-w-7xl mx-auto">
                <h1 className="text-3xl font-bold text-white mb-2">Rotation Curve Visualizer</h1>
                <p className="text-slate-300 mb-6">Explore how different rotation curves affect orbital motion</p>

                <div className="bg-slate-800 rounded-lg p-6 mb-6 border border-slate-700">
                  <label className="block text-white font-semibold mb-3">Select Rotation Curve:</label>
                  <select
                    value={selectedCurve}
                    onChange={(e) => setSelectedCurve(e.target.value)}
                    className="w-full p-3 bg-slate-700 text-white rounded-lg border border-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    {Object.entries(rotationCurves).map(([key, curve]) => (
                      <option key={key} value={key}>
                        {curve.name} - {curve.description}
                      </option>
                    ))}
                  </select>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                  <div className="bg-slate-800 rounded-lg p-6 border border-slate-700">
                    <h2 className="text-xl font-semibold text-white mb-4">Rotation Curve & Enclosed Mass</h2>
                    <div className="bg-slate-700 rounded p-3 mb-3 border border-slate-600">
                      <p className="text-slate-300 text-sm">
                        Enclosed mass calculated using: <span className="font-mono text-blue-300">M(&lt;r) = vÂ²r/G</span>
                      </p>
                    </div>
                    <canvas
                      ref={chartCanvasRef}
                      width={500}
                      height={350}
                      className="w-full rounded-lg"
                    />
                    <p className="text-slate-400 text-sm mt-4">{currentCurve.description}</p>
                  </div>

                  <div className="bg-slate-800 rounded-lg p-6 border border-slate-700">
                    <h2 className="text-xl font-semibold text-white mb-4">Orbital Motion</h2>
                    <canvas
                      ref={orbitCanvasRef}
                      width={500}
                      height={500}
                      onClick={handleCanvasClick}
                      className="w-full rounded-lg border border-slate-700 cursor-crosshair"
                    />
                    <button
                      onClick={resetParticles}
                      className="w-full mt-4 p-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition-colors"
                    >
                      Reset Particles
                    </button>
                    <p className="text-slate-400 text-sm mt-4">
                      Each colored particle orbits at a different radius. Trail length is proportional to velocity. Click/tap to add your own test mass!
                    </p>
                  </div>
                </div>

                <div className="bg-slate-800 rounded-lg p-6 mt-6 border border-slate-700">
                  <h3 className="text-lg font-semibold text-white mb-3">About Rotation Curves</h3>
                  <div className="text-slate-300 space-y-2 text-sm">
                    <p><strong className="text-white">NGC 3198:</strong> A real spiral galaxy 47 million light-years away. Notice how the velocity rises quickly then stays flat</p>
                    <p><strong className="text-white">Homogeneous Disk:</strong> A disk with uniform surface density out to r=1. Inside: velocity increases linearly. Outside: falls off like Keplerian.</p>
                    <p><strong className="text-white">Rigid Body:</strong> All points rotate with the same angular velocity, like a spinning wheel.</p>
                    <p><strong className="text-white">Keplerian/Solar System:</strong> Follows Newton's laws with most mass at the center. Velocity decreases with distance.</p>
                    <p><strong className="text-white">Flat (Idealized):</strong> Perfect constant velocity</p>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<RotationCurveVisualizer />, document.getElementById('root'));
    </script>
</body>
</html>
